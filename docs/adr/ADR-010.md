# User-Focused Testing Strategy for Blazor Web Application

## Status

Proposed

## Context

Traditional testing approaches often focus on implementation details rather than user experience, leading to brittle tests that break when internal structures change, but actual user functionality remains intact. For web applications, especially those serving diverse user bases including users with disabilities, we need a testing strategy that prioritizes user experience and accessibility as the highest valued aspects of the application.

Our Blazor web application serves users with varying abilities and needs. Tests should reflect how real users interact with the application, including those using assistive technologies like screen readers, keyboard navigation, or other accessibility tools.

## Decision

We will adopt a **User-Focused Testing Strategy** that prioritizes user experience and accessibility across all testing levels (unit, integration, and end-to-end tests). This approach emphasizes testing what users actually experience rather than implementation details.

### Core Principles

1. **User Experience First**: Tests should mirror how real users interact with the application
2. **Accessibility by Default**: All tests must consider users with disabilities
3. **Semantic Over Structural**: Query elements by their semantic meaning rather than implementation details
4. **Resilient to Refactoring**: Tests should remain stable when internal structure changes, but user functionality remains the same

### Implementation Strategy

#### 1. Unit Tests: Component Behavior Focus

**Traditional Approach (Avoid):**
```csharp
// Bad: Testing implementation details
var submitButton = component.Find("#submit-btn");
var emailInput = component.Find("input[name='email']");
```

**User-Focused Approach (Preferred):**
```csharp
// Good: Testing user-perceivable behavior
var submitButton = component.FindByRole("button", new { Name = "Submit Order" });
var emailInput = component.FindByLabelText("Email Address");
var errorMessage = component.FindByRole("alert");

// Test accessibility attributes
Assert.True(submitButton.HasAttribute("aria-describedby"));
Assert.Equal("true", emailInput.GetAttribute("aria-required"));
```

**Key Strategies:**
- Use `FindByRole()`, `FindByLabelText()`, `FindByText()` instead of CSS selectors or IDs
- Test ARIA attributes and accessibility properties
- Verify keyboard navigation and focus management
- Test color contrast and visual indicators programmatically where possible

#### 2. Integration Tests: User Journey Focus

**User-Focused Integration Testing:**
```csharp
[Fact]
public async Task UserCanCompleteOrderWithKeyboardNavigation()
{
    // Arrange: Start from user's perspective
    await NavigateToProductPage();
    
    // Act: Simulate real user interaction
    await FocusElement(GetByRole("button", new { Name = "Add to Cart" }));
    await PressKey("Enter");
    
    await FocusElement(GetByRole("link", new { Name = "View Cart" }));
    await PressKey("Enter");
    
    await FocusElement(GetByLabelText("Shipping Address"));
    await TypeText("123 Main St");
    
    await FocusElement(GetByRole("button", new { Name = "Complete Purchase" }));
    await PressKey("Enter");
    
    // Assert: Verify user-perceivable outcomes
    var successMessage = await WaitForElement(GetByRole("alert"));
    Assert.Contains("Order completed successfully", successMessage.TextContent);
    
    // Verify accessibility announcements
    var liveRegion = GetByRole("status");
    Assert.Contains("Order confirmation", liveRegion.TextContent);
}
```

**Key Strategies:**
- Test complete user workflows, not just API endpoints
- Include keyboard-only navigation scenarios
- Test screen reader announcements via live regions
- Verify error states are properly communicated to assistive technologies
- Test with different viewport sizes and zoom levels

#### 3. End-to-End Tests: Real User Simulation

**User-Focused E2E Testing:**
```csharp
[Fact]
public async Task VisuallyImpairedUserCanCompleteCheckout()
{
    // Configure for accessibility testing
    await SetScreenReaderMode(true);
    await SetHighContrastMode(true);
    
    // Navigate like a screen reader user would
    await Page.GotoAsync("/products");
    
    // Use semantic locators
    var productCard = Page.GetByRole(AriaRole.Article).Filter(new { HasText = "Premium Widget" });
    await productCard.GetByRole(AriaRole.Button, new { Name = "Add to Cart" }).ClickAsync();
    
    // Verify announcements
    var announcement = await Page.WaitForSelector("[aria-live='polite']");
    await Expect(announcement).ToContainTextAsync("Added to cart");
    
    // Continue with keyboard navigation
    await Page.Keyboard.PressAsync("Tab");
    await Page.Keyboard.PressAsync("Enter"); // Cart link
    
    // Test form completion with labels
    await Page.GetByLabel("Email Address").FillAsync("user@example.com");
    await Page.GetByLabel("Full Name").FillAsync("John Doe");
    
    // Verify error handling accessibility
    await Page.GetByRole(AriaRole.Button, new { Name = "Submit Order" }).ClickAsync();
    
    var errorAlert = Page.GetByRole(AriaRole.Alert);
    await Expect(errorAlert).ToBeVisibleAsync();
    await Expect(errorAlert).ToContainTextAsync("Payment method required");
}
```

**Key Strategies:**
- Test with accessibility tools enabled (high contrast, screen readers)
- Use `GetByRole()`, `GetByLabel()`, `GetByText()` instead of CSS selectors
- Verify focus management and tab order
- Test error states and success feedback accessibility
- Include tests for different assistive technologies

### Testing Hierarchy Priority

1. **User Goals**: Can users accomplish their primary tasks?
2. **Accessibility**: Can users with disabilities use the application effectively?
3. **User Interface**: Are interactions intuitive and discoverable?
4. **Implementation**: Do internal mechanisms work correctly?

### Query Methods Priority (Most to Least Preferred)

1. `GetByRole()` - Semantic roles (button, textbox, alert, etc.)
2. `GetByLabelText()` - Form labels and accessible names
3. `GetByText()` - Visible text content
4. `GetByDisplayValue()` - Current form values
5. `GetByAltText()` - Image alt text
6. `GetByTitle()` - Title attributes
7. `GetByTestId()` - Only when semantic queries aren't possible
8. CSS Selectors/IDs - Avoid except for styling tests

### Accessibility Testing Checklist

- [ ] Keyboard-only navigation works for all interactive elements
- [ ] Screen reader announcements are meaningful and timely
- [ ] Color is not the only means of conveying information
- [ ] Focus indicators are visible and logical
- [ ] Error messages are associated with form fields
- [ ] Loading states are announced to assistive technologies
- [ ] Dynamic content changes are communicated via live regions
- [ ] Form labels are properly associated with inputs
- [ ] Heading structure is semantic and hierarchical

## Consequences

### Positive
- Tests are more resilient to refactoring and internal changes
- Better coverage of actual user scenarios, especially for users with disabilities
- Improved application accessibility as a side effect of testing strategy
- Tests serve as living documentation of user workflows
- Reduced test maintenance overhead due to semantic stability
- Enhanced confidence in user experience quality

### Negative
- Initial learning curve for developers unfamiliar with accessibility concepts
- May require additional tooling and setup for accessibility testing
- Some edge cases in implementation details might be missed
- Potentially slower test execution due to more comprehensive user simulation

### Mitigation Strategies
- Provide training on accessibility concepts and ARIA attributes
- Create shared utilities and helper methods for common user-focused queries
- Establish code review guidelines emphasizing user-focused test patterns
- Integrate accessibility linting tools into the development pipeline

## References
- [Testing Library Guiding Principles](https://testing-library.com/docs/guiding-principles/)
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [WAI-ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/)
- [bUnit Testing Documentation](https://bunit.dev/)
- [Playwright Accessibility Testing](https://playwright.dev/docs/accessibility-testing)

## Implementation Timeline
- **Phase 1**: Establish testing utilities and helper methods
- **Phase 2**: Convert existing critical path tests to a user-focused approach
- **Phase 3**: Expand coverage to all user workflows
- **Phase 4**: Integration with CI/CD pipeline and accessibility auditing tools

---

*This ADR should be reviewed quarterly to ensure alignment with evolving accessibility standards and user needs.*
